<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flashcard Game</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: linear-gradient(135deg, #eff6ff 0%, #e0e7ff 100%);
        min-height: 100vh;
        line-height: 1.6;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 1rem;
      }

      .header {
        text-align: center;
        margin-bottom: 2rem;
        padding-top: 2rem;
      }

      .title {
        font-size: 2.5rem;
        font-weight: bold;
        color: #1f2937;
        margin-bottom: 1rem;
      }

      .stats {
        display: flex;
        justify-content: center;
        gap: 2rem;
        font-size: 0.875rem;
        color: #4b5563;
        flex-wrap: wrap;
      }

      .stat-item {
        background: white;
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .game-container {
        max-width: 28rem;
        margin: 0 auto;
      }

      .card-container {
        position: relative;
        height: 20rem;
        margin-bottom: 2rem;
        cursor: pointer;
        perspective: 1000px;
        touch-action: pan-y;
      }

      .card-flip {
        transform-style: preserve-3d;
        transition: transform 0.6s;
        width: 100%;
        height: 100%;
        position: relative;
      }

      .card-flip.flipped {
        transform: rotateY(180deg);
      }

      .card-front,
      .card-back {
        backface-visibility: hidden;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: white;
        border-radius: 0.75rem;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1.5rem;
      }

      .card-front {
        border: 4px solid #bfdbfe;
      }

      .card-back {
        transform: rotateY(180deg);
        border: 4px solid #bbf7d0;
      }

      .card-content {
        text-align: center;
      }

      .original-text {
        font-size: 1.875rem;
        font-weight: bold;
        color: #1e40af;
      }

      .russian-text {
        font-size: 1.5rem;
        font-weight: bold;
        color: #166534;
      }

      .controls {
        background: white;
        border-radius: 0.5rem;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        padding: 1.5rem;
        margin-bottom: 1.5rem;
      }

      .controls h3 {
        font-size: 1.125rem;
        font-weight: 600;
        margin-bottom: 1rem;
        text-align: center;
        color: #1f2937;
      }

      .button {
        width: 100%;
        font-weight: 600;
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        border: none;
        cursor: pointer;
        transition: all 0.2s;
        margin-bottom: 0.75rem;
        font-size: 1rem;
      }

      .button:last-child {
        margin-bottom: 0;
      }

      .btn-blue {
        background: #3b82f6;
        color: white;
      }

      .btn-blue:hover {
        background: #2563eb;
      }

      .btn-yellow {
        background: #eab308;
        color: white;
      }

      .btn-yellow:hover {
        background: #ca8a04;
      }

      .btn-green {
        background: #22c55e;
        color: white;
      }

      .btn-green:hover {
        background: #16a34a;
      }

      .instructions {
        background: #f3f4f6;
        border-radius: 0.5rem;
        padding: 1rem;
        font-size: 0.875rem;
        color: #374151;
      }

      .instructions h4 {
        font-weight: 600;
        margin-bottom: 0.5rem;
      }

      .instructions ul {
        list-style-type: disc;
        margin-left: 1.25rem;
      }

      .instructions li {
        margin-bottom: 0.25rem;
      }

      .kbd {
        background: #e5e7eb;
        padding: 0.125rem 0.25rem;
        border-radius: 0.25rem;
        font-family: monospace;
        font-size: 0.75rem;
      }

      .game-over {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .game-over.hidden {
        display: none;
      }

      .game-over-content {
        background: white;
        border-radius: 0.75rem;
        padding: 2rem;
        text-align: center;
        max-width: 28rem;
        margin: 0 1rem;
      }

      .game-over-emoji {
        font-size: 4rem;
        margin-bottom: 1rem;
      }

      .game-over-title {
        font-size: 1.5rem;
        font-weight: bold;
        color: #1f2937;
        margin-bottom: 1rem;
      }

      .game-over-text {
        color: #6b7280;
        margin-bottom: 1.5rem;
      }

      .text-blue {
        color: #2563eb;
      }
      .text-green {
        color: #16a34a;
      }

      .add-words {
        background: white;
        border-radius: 0.5rem;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        padding: 1.5rem;
        margin-bottom: 1.5rem;
      }

      .add-words h3 {
        font-size: 1.125rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: #1f2937;
      }

      .textarea {
        width: 100%;
        min-height: 100px;
        padding: 0.75rem;
        border: 2px solid #e5e7eb;
        border-radius: 0.5rem;
        font-family: monospace;
        font-size: 0.875rem;
        resize: vertical;
        margin-bottom: 0.75rem;
      }

      .textarea:focus {
        outline: none;
        border-color: #3b82f6;
      }

      .input-help {
        font-size: 0.75rem;
        color: #6b7280;
        margin-bottom: 0.75rem;
      }

      .btn-purple {
        background: #8b5cf6;
        color: white;
      }

      .btn-purple:hover {
        background: #7c3aed;
      }

      .btn-red {
        background: #ef4444;
        color: white;
      }

      .btn-red:hover {
        background: #dc2626;
      }

      .storage-controls {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .swipe-indicator {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 3rem;
        opacity: 0;
        transition: opacity 0.2s;
        pointer-events: none;
        z-index: 10;
      }

      .swipe-indicator.show {
        opacity: 0.7;
      }

      .swipe-up {
        color: #22c55e;
      }

      .swipe-down {
        color: #eab308;
      }

      .storage-controls .button {
        flex: 1;
        margin-bottom: 0;
        min-width: 120px;
      }

      @media (max-width: 640px) {
        .title {
          font-size: 2rem;
        }

        .stats {
          gap: 1rem;
        }

        .card-container {
          height: 16rem;
        }

        .original-text {
          font-size: 1.5rem;
        }

        .russian-text {
          font-size: 1.25rem;
        }

        .instructions {
          font-size: 0.8rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Header -->
      <div class="header">
        <h1 class="title">Flashcards</h1>
        <div class="stats">
          <div class="stat-item">
            <span><strong>My cards:</strong></span>
            <span id="cardsLeft" class="text-blue"></span>
          </div>
          <div class="stat-item">
            <span><strong>Done:</strong></span>
            <span id="knownCount" class="text-green"></span>
          </div>
        </div>
      </div>

      <!-- Game Container -->
      <div class="game-container">

        <!-- Card -->
        <div id="cardContainer" class="card-container">
          <div id="flashcard" class="card-flip">
            <!-- Front -->
            <div class="card-front">
              <div class="card-content">
                <div id="word" class="original-text">Click to start!</div>
              </div>
            </div>
            <!-- Back (Russian) -->
            <div class="card-back">
              <div class="card-content">
                <div id="translation" class="russian-text">Translation</div>
              </div>
            </div>
          </div>
          <!-- Swipe Indicators -->
          <div id="swipeIndicator" class="swipe-indicator"></div>
        </div>

        <!-- Controls -->
        <div class="controls">
          <h3>Controls</h3>
          <button id="flipBtn" class="button btn-blue">üîÑ Flip Card (Space/Tap)</button>
          <button id="nextBtn" class="button btn-yellow">‚è≠Ô∏è Next Card (N/Swipe up)</button>
          <button id="knowBtn" class="button btn-green">‚úÖ I Know This (K/Swipe down)</button>
        </div>

        <!-- Instructions -->
        <div class="instructions">
          <h4>How to play:</h4>
          <ul>
            <li>
              Click the card or press <span class="kbd">Space</span> or <span class="kbd">Tap</span> to flip and see
              translation
            </li>
            <li>
              Press <span class="kbd">N</span> or <span class="kbd">Swipe up</span> to move current word to end of queue
            </li>
            <li>
              Press <span class="kbd">K</span> or <span class="kbd">Swipe down</span> if you know the word (removes from queue)
            </li>
            <li>
              <strong>Mobile:</strong> Swipe ‚¨ÜÔ∏è to mark as known, swipe ‚¨áÔ∏è to move to
              end
            </li>
          </ul>
        </div>

        <!-- Add Words Section -->
        <div class="add-words">
          <h3>Add New Words</h3>
          <textarea
            id="newWordsInput"
            class="textarea"
            placeholder="Enter words in format: word=translation&#10;Example:&#10;bonjour	hello&#10;merci	thank you"
          ></textarea>
          <div class="input-help">
            Format: word=translation (one pair per line)
          </div>
          <div class="storage-controls">
            <button id="addWordsBtn" class="button btn-purple">‚ûï Add Words</button>
            <button id="resetBtn" class="button btn-red">üîÑ Reset All</button>
          </div>
        </div>

      <!-- Game Over Screen -->
      <div id="gameOver" class="game-over hidden">
        <div class="game-over-content">
          <div class="game-over-emoji">üéâ</div>
          <h2 class="game-over-title">Congratulations!</h2>
          <p class="game-over-text">You've learned all 87 words!</p>
          <button id="restartBtn" class="button btn-blue">Start Over</button>
        </div>
      </div>
    </div>

    <script>
      // Vocabulary data
      const verbs = [
        { original: "abandonner", translation: "–±—Ä–æ—Å–∞—Ç—å, –æ—Å—Ç–∞–≤–ª—è—Ç—å" },
        { original: "accorder", translation: "–ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—Ç—å, –¥–∞–≤–∞—Ç—å" },
        { original: "adapter", translation: "–∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞—Ç—å, –ø—Ä–∏—Å–ø–æ—Å–∞–±–ª–∏–≤–∞—Ç—å" },
        { original: "adopter", translation: "–ø—Ä–∏–Ω–∏–º–∞—Ç—å, —É—Å–≤–∞–∏–≤–∞—Ç—å" },
        { original: "aider", translation: "–ø–æ–º–æ–≥–∞—Ç—å" },
        { original: "aimer", translation: "–ª—é–±–∏—Ç—å" },
        { original: "aller", translation: "–∏–¥—Ç–∏, –µ—Ö–∞—Ç—å" },
        { original: "am√©liorer", translation: "—É–ª—É—á—à–∞—Ç—å" },
        { original: "ancrer", translation: "–∑–∞–∫—Ä–µ–ø–ª—è—Ç—å" },
        { original: "apprendre", translation: "–∏–∑—É—á–∞—Ç—å, —É—á–∏—Ç—å—Å—è" },
        { original: "approcher", translation: "–ø—Ä–∏–±–ª–∏–∂–∞—Ç—å—Å—è" },
        { original: "atteindre", translation: "–¥–æ—Å—Ç–∏–≥–∞—Ç—å" },
        { original: "avoir", translation: "–∏–º–µ—Ç—å" },
        { original: "commander", translation: "–∑–∞–∫–∞–∑—ã–≤–∞—Ç—å" },
        { original: "commettre", translation: "—Å–æ–≤–µ—Ä—à–∞—Ç—å" },
        { original: "comprendre", translation: "–ø–æ–Ω–∏–º–∞—Ç—å" },
        { original: "concerner", translation: "–∫–∞—Å–∞—Ç—å—Å—è" },
        { original: "conna√Ætre", translation: "–∑–Ω–∞—Ç—å" },
        { original: "conseiller", translation: "—Å–æ–≤–µ—Ç–æ–≤–∞—Ç—å" },
        { original: "continuer", translation: "–ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å" },
        { original: "cr√©er", translation: "—Å–æ–∑–¥–∞–≤–∞—Ç—å" },
        { original: "demander", translation: "—Å–ø—Ä–∞—à–∏–≤–∞—Ç—å" },
        { original: "d√©pendre", translation: "–∑–∞–≤–∏—Å–µ—Ç—å" },
        { original: "d√©tester", translation: "–Ω–µ–Ω–∞–≤–∏–¥–µ—Ç—å" },
        { original: "d√©velopper", translation: "—Ä–∞–∑–≤–∏–≤–∞—Ç—å" },
        { original: "devoir", translation: "–±—ã—Ç—å –¥–æ–ª–∂–Ω—ã–º" },
        { original: "dire", translation: "–≥–æ–≤–æ—Ä–∏—Ç—å" },
        { original: "donner", translation: "–¥–∞–≤–∞—Ç—å" },
        { original: "√©couter", translation: "—Å–ª—É—à–∞—Ç—å" },
        { original: "√©crire", translation: "–ø–∏—Å–∞—Ç—å" },
        { original: "entendre", translation: "—Å–ª—ã—à–∞—Ç—å" },
        { original: "entretenir", translation: "–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å" },
        { original: "esp√©rer", translation: "–Ω–∞–¥–µ—è—Ç—å—Å—è" },
        { original: "essayer", translation: "–ø—ã—Ç–∞—Ç—å—Å—è" },
        { original: "√©tudier", translation: "–∏–∑—É—á–∞—Ç—å" },
        { original: "√©viter", translation: "–∏–∑–±–µ–≥–∞—Ç—å" },
        { original: "exercer", translation: "—É–ø—Ä–∞–∂–Ω—è—Ç—å" },
        { original: "exister", translation: "—Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å" },
        { original: "exprimer", translation: "–≤—ã—Ä–∞–∂–∞—Ç—å" },
        { original: "faire", translation: "–¥–µ–ª–∞—Ç—å" },
        { original: "finir", translation: "–∑–∞–∫–∞–Ω—á–∏–≤–∞—Ç—å" },
        { original: "fixer", translation: "—É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å" },
        { original: "fonctionner", translation: "—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞—Ç—å" },
        { original: "forger", translation: "–∫–æ–≤–∞—Ç—å" },
        { original: "fuir", translation: "–±–µ–∂–∞—Ç—å" },
        { original: "garder", translation: "—Ö—Ä–∞–Ω–∏—Ç—å" },
        { original: "habiter", translation: "–∂–∏—Ç—å" },
        { original: "habituer", translation: "–ø—Ä–∏–≤—ã–∫–∞—Ç—å" },
        { original: "identifier", translation: "–æ–ø—Ä–µ–¥–µ–ª—è—Ç—å" },
        { original: "imaginer", translation: "–≤–æ–æ–±—Ä–∞–∂–∞—Ç—å" },
        { original: "int√©grer", translation: "–∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å" },
        { original: "int√©resser", translation: "–∏–Ω—Ç–µ—Ä–µ—Å–æ–≤–∞—Ç—å" },
        { original: "inviter", translation: "–ø—Ä–∏–≥–ª–∞—à–∞—Ç—å" },
        { original: "lire", translation: "—á–∏—Ç–∞—Ç—å" },
        { original: "maltraiter", translation: "–ø–ª–æ—Ö–æ –æ–±—Ä–∞—â–∞—Ç—å—Å—è" },
        { original: "manquer", translation: "–Ω–µ —Ö–≤–∞—Ç–∞—Ç—å" },
        { original: "mesurer", translation: "–∏–∑–º–µ—Ä—è—Ç—å" },
        { original: "n√©gliger", translation: "–ø—Ä–µ–Ω–µ–±—Ä–µ–≥–∞—Ç—å" },
        { original: "nourrir", translation: "–ø–∏—Ç–∞—Ç—å" },
        { original: "obtenir", translation: "–ø–æ–ª—É—á–∞—Ç—å" },
        { original: "oublier", translation: "–∑–∞–±—ã–≤–∞—Ç—å" },
        { original: "para√Ætre", translation: "–∫–∞–∑–∞—Ç—å—Å—è" },
        { original: "parler", translation: "–≥–æ–≤–æ—Ä–∏—Ç—å" },
        { original: "participer", translation: "—É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å" },
        { original: "passer", translation: "–ø—Ä–æ—Ö–æ–¥–∏—Ç—å" },
        { original: "payer", translation: "–ø–ª–∞—Ç–∏—Ç—å" },
        { original: "permettre", translation: "–ø–æ–∑–≤–æ–ª—è—Ç—å" },
        { original: "pers√©v√©rer", translation: "—É–ø–æ—Ä—Å—Ç–≤–æ–≤–∞—Ç—å" },
        { original: "personnaliser", translation: "–ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å" },
        { original: "pouvoir", translation: "–º–æ—á—å" },
        { original: "pratiquer", translation: "–ø—Ä–∞–∫—Ç–∏–∫–æ–≤–∞—Ç—å" },
        { original: "prendre", translation: "–±—Ä–∞—Ç—å" },
        { original: "pr√©senter", translation: "–ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—Ç—å" },
        { original: "privil√©gier", translation: "–æ—Ç–¥–∞–≤–∞—Ç—å –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–µ" },
        { original: "progresser", translation: "–ø—Ä–æ–≥—Ä–µ—Å—Å–∏—Ä–æ–≤–∞—Ç—å" },
        { original: "profiter", translation: "–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è" },
        { original: "recommander", translation: "—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞—Ç—å" },
        { original: "redoubler", translation: "—É–¥–≤–∞–∏–≤–∞—Ç—å" },
        { original: "regarder", translation: "—Å–º–æ—Ç—Ä–µ—Ç—å" },
        { original: "r√©p√©ter", translation: "–ø–æ–≤—Ç–æ—Ä—è—Ç—å" },
        { original: "rester", translation: "–æ—Å—Ç–∞–≤–∞—Ç—å—Å—è" },
        { original: "r√©sister", translation: "—Å–æ–ø—Ä–æ—Ç–∏–≤–ª—è—Ç—å—Å—è" },
        { original: "r√©ussir", translation: "—É–¥–∞–≤–∞—Ç—å—Å—è" },
        { original: "savoir", translation: "–∑–Ω–∞—Ç—å" },
        { original: "sentir", translation: "—á—É–≤—Å—Ç–≤–æ–≤–∞—Ç—å" },
        { original: "stagner", translation: "–∑–∞—Å—Ç–∞–∏–≤–∞—Ç—å—Å—è" },
        { original: "stresser", translation: "–Ω–µ—Ä–≤–Ω–∏—á–∞—Ç—å" },
        { original: "structurer", translation: "—Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞—Ç—å" },
        { original: "suivre", translation: "—Å–ª–µ–¥–æ–≤–∞—Ç—å" },
        { original: "t√¢cher", translation: "—Å—Ç–∞—Ä–∞—Ç—å—Å—è" },
        { original: "travailler", translation: "—Ä–∞–±–æ—Ç–∞—Ç—å" },
        { original: "tromper", translation: "–æ–±–º–∞–Ω—ã–≤–∞—Ç—å" },
        { original: "utiliser", translation: "–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å" },
        { original: "voir", translation: "–≤–∏–¥–µ—Ç—å" },
        { original: "vouloir", translation: "—Ö–æ—Ç–µ—Ç—å" },
      ];

      // Game state
      let gameQueue = [];
      let knownWords = [];
      let allWords = [...verbs];
      let currentCard = null;
      let isFlipped = false;
      let gameStarted = false;

      // Touch handling
      let touchStartY = 0;
      let touchStartX = 0;
      let isSwiping = false;

      // Storage keys
      const STORAGE_KEYS = {
        gameQueue: "cards_gameQueue",
        knownWords: "cards_knownWords",
        allWords: "cards_allWords",
        gameStarted: "cards_gameStarted",
      };

      // DOM elements
      const flashcard = document.getElementById("flashcard");
      const word = document.getElementById("word");
      const translation = document.getElementById("translation");
      const cardsLeft = document.getElementById("cardsLeft");
      const knownCount = document.getElementById("knownCount");
      const cardContainer = document.getElementById("cardContainer");
      const gameOver = document.getElementById("gameOver");
      const restartBtn = document.getElementById("restartBtn");
      const flipBtn = document.getElementById("flipBtn");
      const nextBtn = document.getElementById("nextBtn");
      const knowBtn = document.getElementById("knowBtn");
      const newWordsInput = document.getElementById("newWordsInput");
      const addWordsBtn = document.getElementById("addWordsBtn");
      const resetBtn = document.getElementById("resetBtn");
      const swipeIndicator = document.getElementById("swipeIndicator");

      // Local Storage functions
      function saveGameState() {
        try {
          localStorage.setItem(STORAGE_KEYS.gameQueue, JSON.stringify(gameQueue));
          localStorage.setItem(STORAGE_KEYS.knownWords, JSON.stringify(knownWords));
          localStorage.setItem(STORAGE_KEYS.allWords, JSON.stringify(allWords));
          localStorage.setItem(STORAGE_KEYS.gameStarted, JSON.stringify(gameStarted));
        } catch (e) {
          console.warn("Could not save game state to localStorage:", e);
        }
      }

      function loadGameState() {
        try {
          const savedQueue = localStorage.getItem(STORAGE_KEYS.gameQueue);
          const savedKnown = localStorage.getItem(STORAGE_KEYS.knownWords);
          const savedAllWords = localStorage.getItem(STORAGE_KEYS.allWords);
          const savedGameStarted = localStorage.getItem(STORAGE_KEYS.gameStarted);

          if (savedQueue) gameQueue = JSON.parse(savedQueue);
          if (savedKnown) knownWords = JSON.parse(savedKnown);
          if (savedAllWords) allWords = JSON.parse(savedAllWords);
          if (savedGameStarted) gameStarted = JSON.parse(savedGameStarted);

          // If no saved data or empty queue, initialize with default verbs
          if (!savedQueue || gameQueue.length === 0) {
            gameQueue = shuffleArray([...allWords]);
            gameStarted = false;
          }

          return true;
        } catch (e) {
          console.warn("Could not load game state from localStorage:", e);
          return false;
        }
      }

      // Flip card (only if not swiping)
      function flipCard() {
        if (isSwiping) {
          isSwiping = false;
          return;
        }

        if (!gameStarted) {
          startGame();
          return;
        }

        isFlipped = !isFlipped;
        flashcard.classList.toggle("flipped");
      }

      // Show swipe indicator
      function showSwipeIndicator(direction) {
        if (direction === "up") {
          swipeIndicator.textContent = "‚úÖ";
          swipeIndicator.className = "swipe-indicator swipe-up show";
        } else if (direction === "down") {
          swipeIndicator.textContent = "‚è≠Ô∏è";
          swipeIndicator.className = "swipe-indicator swipe-down show";
        }
      }

      // Hide swipe indicator
      function hideSwipeIndicator() {
        swipeIndicator.className = "swipe-indicator";
      }

      // Touch event handlers
      function handleTouchStart(e) {
        if (!gameStarted || gameQueue.length === 0) return;

        const touch = e.touches[0];
        touchStartY = touch.clientY;
        touchStartX = touch.clientX;
        isSwiping = false;
      }

      function handleTouchMove(e) {
        if (!gameStarted || gameQueue.length === 0) return;

        const touch = e.touches[0];
        const deltaY = touch.clientY - touchStartY;
        const deltaX = touch.clientX - touchStartX;

        // Only consider vertical swipes (more Y movement than X)
        if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > 30) {
          isSwiping = true;

          if (deltaY < -50) {
            // Swipe up
            showSwipeIndicator("up");
          } else if (deltaY > 50) {
            // Swipe down
            showSwipeIndicator("down");
          } else {
            hideSwipeIndicator();
          }
        } else if (Math.abs(deltaY) < 20 && Math.abs(deltaX) < 20) {
          hideSwipeIndicator();
          isSwiping = false;
        }
      }

      function handleTouchEnd(e) {
        if (!gameStarted || gameQueue.length === 0) return;

        const touch = e.changedTouches[0];
        const deltaY = touch.clientY - touchStartY;
        const deltaX = touch.clientX - touchStartX;

        hideSwipeIndicator();

        // Only process swipe if it was primarily vertical
        if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > 50) {
          if (deltaY < -50) {
            // Swipe up - mark as known
            markAsKnown();
            isSwiping = true;
          } else if (deltaY > 50) {
            // Swipe down - move to end
            moveToEnd();
            isSwiping = true;
          }
        }
      }

      // Shuffle array function
      function shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }

      // Initialize game
      function initGame() {
        // Try to load saved state first
        const loaded = loadGameState();

        if (!loaded || gameQueue.length === 0) {
          // If no saved state or empty queue, reset to shuffled default verbs
          gameQueue = shuffleArray([...allWords]);
          knownWords = [];
          gameStarted = false;
        }

        isFlipped = false;
        flashcard.classList.remove("flipped");

        if (gameStarted && gameQueue.length > 0) {
          currentCard = gameQueue[0];
          word.textContent = currentCard.original;
          translation.textContent = currentCard.translation;
        } else {
          word.textContent = "Click to start!";
          translation.textContent = "–ü–µ—Ä–µ–≤–æ–¥";
        }

        updateCounters();
        saveGameState();
      }

      // Parse new words from textarea
      function parseNewWords(text) {
        const lines = text.trim().split("\n");
        const newWords = [];

        for (let line of lines) {
          line = line.trim();
          if (!line) continue;

          const parts = line.split("=");
          if (parts.length >= 2) {
            const original = parts[0].trim();
            const translation = parts[1].trim();

            if (original && translation) {
              // Check if word already exists
              const exists = allWords.some(
                (word) => word.original.toLowerCase() === original.toLowerCase(),
              );

              if (!exists) {
                newWords.push({ original, translation });
              }
            }
          }
        }

        return newWords;
      }

      // Add new words to the game
      function addNewWords() {
        const inputText = newWordsInput.value;
        if (!inputText.trim()) return;

        const newWords = parseNewWords(inputText);
        if (newWords.length === 0) {
          alert(
            "No valid words found. Please check the format:\nword=translation",
          );
          return;
        }

        // Add to all words
        allWords.push(...newWords);

        // Shuffle new words and add to end of queue
        const shuffledNewWords = shuffleArray([...newWords]);
        gameQueue.push(...shuffledNewWords);

        // Clear input
        newWordsInput.value = "";

        // Update UI and save
        updateCounters();
        saveGameState();

        alert(`Added ${newWords.length} new words to the game!`);
      }

      // Reset entire game
      function resetGame() {
        if (
          confirm("This will reset all progress and remove custom words. Are you sure?")
        ) {
          clearGameState();
          allWords = [...verbs]; // Reset to original verbs only
          gameQueue = shuffleArray([...allWords]);
          knownWords = [];
          gameStarted = false;
          isFlipped = false;
          flashcard.classList.remove("flipped");
          word.textContent = "Click to start!";
          translation.textContent = "–ü–µ—Ä–µ–≤–æ–¥";
          newWordsInput.value = "";
          updateCounters();
          saveGameState();
        }
      }

      // Start game
      function startGame() {
        if (!gameStarted) {
          gameStarted = true;
          nextCard();
        }
      }

      // Show next card
      function nextCard() {
        if (gameQueue.length === 0) {
          showGameOver();
          return;
        }

        currentCard = gameQueue[0];
        isFlipped = false;
        flashcard.classList.remove("flipped");
        word.textContent = currentCard.original;
        translation.textContent = currentCard.translation;
        saveGameState();
      }

      // Move current word to end of queue
      function moveToEnd() {
        if (!gameStarted || gameQueue.length === 0) return;

        const word = gameQueue.shift();
        gameQueue.push(word);
        nextCard();
      }

      // Mark word as known
      function markAsKnown() {
        if (!gameStarted || gameQueue.length === 0) return;

        const word = gameQueue.shift();
        knownWords.push(word);
        updateCounters();
        nextCard();
      }

      // Update counters
      function updateCounters() {
        cardsLeft.textContent = gameQueue.length;
        knownCount.textContent = knownWords.length;
      }

      // Show game over screen
      function showGameOver() {
        gameOver.classList.remove("hidden");
      }

      // Restart game
      function restartGame() {
        gameOver.classList.add("hidden");
        // Reset queue from all words (including custom ones)
        gameQueue = shuffleArray([...allWords]);
        knownWords = [];
        gameStarted = false;
        isFlipped = false;
        flashcard.classList.remove("flipped");
        word.textContent = "Click to start!";
        translation.textContent = "–ü–µ—Ä–µ–≤–æ–¥";
        updateCounters();
        saveGameState();
      }

      // Event listeners
      cardContainer.addEventListener("click", flipCard);
      cardContainer.addEventListener("touchstart", handleTouchStart, { passive: true });
      cardContainer.addEventListener("touchmove", handleTouchMove, { passive: true });
      cardContainer.addEventListener("touchend", handleTouchEnd, { passive: true });
      flipBtn.addEventListener("click", flipCard);
      nextBtn.addEventListener("click", moveToEnd);
      knowBtn.addEventListener("click", markAsKnown);
      restartBtn.addEventListener("click", restartGame);
      addWordsBtn.addEventListener("click", addNewWords);
      resetBtn.addEventListener("click", resetGame);

      // Keyboard controls
      document.addEventListener("keydown", (e) => {
        switch (e.key.toLowerCase()) {
          case " ":
            e.preventDefault();
            flipCard();
            break;
          case "n":
            moveToEnd();
            break;
          case "k":
            markAsKnown();
            break;
        }
      });

      // Initialize game on load
      initGame();
    </script>
  </body>
</html>
